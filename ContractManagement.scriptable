{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "yellow",
    "glyph" : "edit"
  },
  "name" : "ContractManagement",
  "script" : "const calendarName = \"Familienkalender\"\nconst reminderListName = \"Verwaltung\"\nconst fm = FileManager.local()\nconst path = fm.bookmarkedPath(\"Sync_Ordner\")\n\nconst metaDataFileName = \"contractMetaData.json\"\nconst metaDataFilePath = fm.joinPath(path, metaDataFileName)\nconst metaDataFileContent = fm.readString(metaDataFilePath)\nconst metaData = JSON.parse(metaDataFileContent)\n\nconst contractsFileName = \"contracts.json\"\nconst contractsFilePath = fm.joinPath(path, contractsFileName)\nconst contractsFileContent = fm.readString(contractsFilePath)\nvar   contracts = JSON.parse(contractsFileContent)\n\nconst essentials = [\"EntryType\", \"Titel\", \"Owner\"];\nconst essentialsAppointment = [\"EventDate\", \"PreparationPeriod\", \"NoticePeriod\"];\nconst essentialsPayment = [\"PaymentValue\", \"PaymentPeriod\"];\nconst unshownParameters = [\"AppointmentManagement\", \"PaymentManagement\", \"ReminderBegin\", \"ReminderEnd\", \"ID\", \"AppointmentSuffix\", \"ReminderSuffix\", \"CreationDate\", \"LastUpdate\"];\n\nvar filterObjects = new Object();        \n    filterObjects.Status = \"laufend\";\nvar deletedObject = \"\";\n\nconst today = new Date()\nconst inOneYear = new Date(today.getFullYear() + 1, today.getMonth(), today.getDate());   \nconst inThreeYears = new Date(today.getFullYear() + 3, today.getMonth(), today.getDate());   \n\nvar cal\nvar eventPromises = retrieveEvents();\n\nvar reminderPromises = retrieveReminders();\n\nvar table = new UITable();\n\nvar df = new DateFormatter();\n    df.dateFormat = \"yyyy-MM-dd\"\nvar dfTime = new DateFormatter();\n    dfTime.dateFormat = df.dateFormat + \"'T'HH:mm:ssZ\"\nvar dfTimeToDo = new DateFormatter();\n    dfTimeToDo.dateFormat = df.dateFormat + \" HH:mm:ss\"\n\nvar entry = new Object();\nvar contractKey;\nvar contractValue = new Object();\n\nvar selectionTable = new UITable();\n    selectionTable.dismissOnTap = true;\n    selectionTable.showSeparators = true; \n\nconst widget = new ListWidget()\n\nif ( !config.runsInWidget ){    \n\n\n  await  inputModus()\n\/\/        await createWidget()\n\/\/        await widget.presentLarge()\n} else {        \n    await createWidget()\n    Script.setWidget(widget)    \n    Script.complete()\n}\n\n\/\/ build the content of the widget\nasync function createWidget() {        \n    widget.setPadding(10, 10, 10, 10)\n    const sizeTextLarge = 11;    \n    const sizeHeadlineLarge = 13;    \n    const sizeDatesLarge = 11;    \n    const numberOfChangesLarge = 2; \n    let sizeText = 9;\n    let sizeHeadline = 11;\n    let sizeDates = 9;    \n    let numberOfChanges = 1;\n    \n    if (config.widgetFamily === \"large\") {\n        sizeText = sizeTextLarge;\n        sizeHeadline = sizeHeadlineLarge;\n        sizeDates = sizeDatesLarge;    \n        numberOfChanges = numberOfChangesLarge;\n    }\n\n    contractValue = Object.values(contracts);\n    let activeContracts = contractValue.filter(function (x) { return x.Status == \"laufend\" });\n    let appointmentManagement = activeContracts.filter(function (x) { return x.AppointmentManagement == \"Ja\" });\n    let numberAppointmentManagement = Object.keys(appointmentManagement).length\n    let paymentManagement = activeContracts.filter(function (x) { return x.PaymentManagement == \"Ja\" });\n\n    var sortiertEventDate = appointmentManagement.sort(function(x, y){return new Date(x.EventDate) - new Date(y.EventDate)});\n\/\/    let sortiertReminderEnd = appointmentManagement.sort(function(x, y){return new Date(x.ReminderEnd) - new Date(y.ReminderEnd)});\n\n    let numberOfContracts = Object.keys(contracts).length;\n    const date1 = new Date(Date.parse(sortiertEventDate[0].EventDate));\n \n   \n    let keyparameters = widget.addText(\"Einträge\/Laufend\/Termine\/Zahlungen \"+ numberOfContracts.toString() + \" \/ \"+ activeContracts.length + \" \/ \"+ appointmentManagement.length + \" \/ \"+ paymentManagement.length);           \n  keyparameters.font = Font.boldMonospacedSystemFont(10) \n  \n    \/\/ ========================================================================\n    \/\/    \n    \/\/ *** Next Projects   \n    \/\/  \n    \/\/ ========================================================================\n\n    let sortiertReminderBegin = appointmentManagement.sort(function(x, y){return new Date(x.ReminderBegin) - new Date(y.ReminderBegin)});\n\n    widget.addSpacer(3)\n    let contentDates = []\n    let contentText = []\n    for (let i in sortiertReminderBegin){\n        contentDates[i] = sortiertReminderBegin[i].ReminderBegin\n        contentText[i]  = sortiertReminderBegin[i].Titel + \" von \" + sortiertReminderBegin[i].Owner + \" \" + sortiertReminderBegin[i].ReminderSuffix + \" bis \" + sortiertReminderBegin[i].ReminderEnd\n    }      \n    listSectionOfWidget(\"Anstehende Projekte\", contentDates, contentText, numberOfChanges)\n\n\n    \/\/ ========================================================================\n    \/\/    \n    \/\/ *** Present next Event\n    \/\/          \n    \/\/ ========================================================================\n    widget.addSpacer(3)\n    contentDates = []\n    contentText = []\n    for (let i in sortiertEventDate){\n        contentDates[i] = sortiertEventDate[i].EventDate\n        contentText[i]  = sortiertEventDate[i].Titel + \" von \" + sortiertEventDate[i].Owner + \" \" + sortiertEventDate[i].AppointmentSuffix\n    }      \n    listSectionOfWidget(\"Nächste Ereignisse\", contentDates, contentText, numberOfChanges)\n\n\n    \/\/ ========================================================================\n    \/\/    \n    \/\/ *** Gant-Chart  \n    \/\/          \n    \/\/ ========================================================================\n\n    sortiertReminderBegin = appointmentManagement.sort(function(x, y){return new Date(x.ReminderBegin) - new Date(y.ReminderBegin)});\n\n    let gantChartForWidget;\n    gantChartForWidget = GantChart(sortiertReminderBegin)\n    widget.addSpacer(2)\n    widget.addImage(gantChartForWidget)\n  \n \n    \/\/ ========================================================================\n    \/\/    \n    \/\/ *** Payments\n    \/\/          \n    \/\/ ========================================================================\n\n    widget.addSpacer(2)\n    const caption4 = widget.addText(\"Ausgaben\")   \n          caption4.font = Font.boldMonospacedSystemFont(sizeHeadline)\n          caption4.textColor = Color.gray()\n    \n    let graphikZeile1 = widget.addStack();\n    let bild = [];\n    let block = [];\n    let unterschrift = [];\n    let ueberschrift = [];\n    graphikZeile1.addSpacer(5)\n\n    let partialPaymentManagement = [];    \n    let monthlyRates = [];\n    let monthlyMeanRate = [];\n    let selection = [\"Total\", \"Vertrag\", \"Kredit\", \"Nebenkosten\"];\n    for (let x in selection) {\n        if (x == 0) {\n            partialPaymentManagement[x] = paymentManagement;\n        } else {\n            partialPaymentManagement[x] = paymentManagement.filter(function (y) { return y.EntryType === selection[x].toString() });\n        }        \n        monthlyRates[x] = calculatePayments(partialPaymentManagement[x])                \n        monthlyMeanRate[x] = 0\n        for (let z of monthlyRates[x]) {\n            monthlyMeanRate[x] += z \/ 12\n        }   \n        \n    }\n\n\n    for (let i in selection) {    \n        block[i] =  graphikZeile1.addStack();     \n        block[i].layoutVertically();\n        block[i].addSpacer(2)    \n        \n        ueberschrift[i] = block[i].addText(selection[i].toString())\n        ueberschrift[i].rightAlignText()\n        ueberschrift[i].font = Font.boldSystemFont(sizeText)\n        ueberschrift[i].textColor = Color.red()\n        ueberschrift[i].font = Font.boldSystemFont(sizeDates)        \n \n        unterschrift[i] = block[i].addText(\"Ø\" + monthlyMeanRate[i].toFixed(2).toLocaleString() + \"€\")\n        unterschrift[i].rightAlignText()\n        unterschrift[i].font = Font.boldSystemFont(sizeText)\n        unterschrift[i] = block[i].addText(monthlyRates[i][today.getMonth()].toFixed(2).toString() + \"€\")\n        unterschrift[i].rightAlignText()\n        unterschrift[i].font = Font.boldSystemFont(sizeText)\n \n        bild[i] = block[i].addImage(balkenDiagramm(monthlyRates[i]));\n  \n        graphikZeile1.addSpacer()    \n        graphikZeile1.addStack\n    }\n\n    \/\/ ========================================================================\n    \/\/    \n    \/\/ *** Last changes in data base \n    \/\/          \n    \/\/ ========================================================================\n    let sortiertLastUpdate = contractValue.sort(function(x, y){  \n        let a = Date.parse(x.LastUpdate); \n        let b = Date.parse(y.LastUpdate);\n        return b - a\n    });\n    widget.addSpacer(2)\n    const caption3 = widget.addText(\"Letzte Aktualisierung\")   \n          caption3.font = Font.boldMonospacedSystemFont(sizeHeadline)    \n          caption3.textColor = Color.gray()\n  \n    let zeileAktualisierung = [];  \n    let linksAktualisierung = [];\n    let linksAktualisierungText = [];\n      \n    for (let i = 0; i < numberOfChanges; i++) { \n        zeileAktualisierung[i] = widget.addStack()\n        linksAktualisierung[i] = zeileAktualisierung[i].addStack()\n        linksAktualisierungText[i] = linksAktualisierung[i].addText(sortiertLastUpdate[i].Titel + \" von \" + sortiertLastUpdate[i].Owner)\n        linksAktualisierungText[i].font = Font.boldSystemFont(sizeText)\n    }\n\n\n\n    function listSectionOfWidget(headline, contentDates, contentText, amount){\n    \/\/    widget.addSpacer(5)\n        const caption = widget.addText(headline)   \n              caption.font = Font.boldMonospacedSystemFont(sizeHeadline)\n              caption.textColor = Color.gray()\n        const dateStack = widget.addStack()\n              dateStack.layoutHorizontally()\n        let row = [];  \n        let left = [];\n        let right = [];\n        let leftText = [];\n        let rightText = [];\n          \n        for (let i = 0; i < amount; i++) { \n            row[i] = widget.addStack()\n            left[i] = row[i].addStack()\n            leftText[i] = left[i].addText(contentDates[i])\n            leftText[i].textColor = Color.red()\n            leftText[i].font = Font.boldSystemFont(sizeDates)        \n            row[i].addSpacer(5)\n            right[i] = row[i].addStack()\n            rightText[i] = right[i].addText(contentText[i])\n            rightText[i].font = Font.boldSystemFont(sizeText)\n            row[i].addSpacer()\n        }\n    }\n}\n\n\nasync function inputModus(){\n    var gantChartPicture;\n    createSelectionTable()\n    await selectionTable.present(true)       \n}\n\nasync function createSelectionTable(){\n    selectionTable.removeAllRows()    \n    let headlineFilterRow = new UITableRow();\n    let headlineFilterCell = headlineFilterRow.addText(\"Filter\", \"Zu- oder abwählen von Filtern.\")    \n    selectionTable.addRow(headlineFilterRow)\n    let filteredContracts = contracts;\n    let filteredContractValues = Object.values(filteredContracts);        \n    for (let filterKey of Object.keys(filterObjects) ) {\n        let filterValue = filterObjects[filterKey];    \n        filteredContractValues = filteredContractValues.filter( x =>  x[filterKey] === filterValue );        \n    }          \n    let shownFilter = Object.keys(filterObjects)\n    shownFilter.push(\"addParameter\")\n    createRow(shownFilter, selectionTable, filterObjects)\n\n    let headlineContractRow = new UITableRow();\n    let headlineContractCell = headlineContractRow.addText(\"Verträge\", \"Bitte Vertrag auswählen.\")    \n        headlineContractCell.widthWeight = 100\n    let paymentSummaryCell\n    let filteredWithPayment = filteredContractValues.filter(function (x) { return x.PaymentManagement == \"Ja\" });    \n\n    if ( filteredWithPayment.length > 0) {    \n        let monthlyRates = calculatePayments(filteredWithPayment);\n        let paymentSummaryPicture;   \n        paymentSummaryPicture = balkenDiagramm(monthlyRates);\n        paymentSummaryCell = headlineContractRow.addImage(paymentSummaryPicture) \n    } else {\n        paymentSummaryCell = headlineContractRow.addText(\"Keine Zahlungen\")\n    }\n    paymentSummaryCell.widthWeight = 50\n\n    let filteredWithAppointment = filteredContractValues.filter(function (x) { return x.AppointmentManagement == \"Ja\" });    \n    let gantChartSummary\n    let gantChartSummaryPicture        \n    let selectedFilteredReminderBeginn\n    if ( filteredWithAppointment.length > 0) {\n        selectedFilteredReminderBeginn = filteredWithAppointment.sort(function(x, y){return new Date(x.ReminderBegin) - new Date(y.ReminderBegin)});\n        gantChartSummaryPicture = GantChart(selectedFilteredReminderBeginn)\n        gantChartCell = headlineContractRow.addImage(gantChartSummaryPicture) \n    } else {\n        gantChartCell = headlineContractRow.addText(\"Keine Termine\")\n    }\n    gantChartCell.widthWeight = 50\n\n\n    selectionTable.addRow(headlineContractRow)\n\n\n    let row = new UITableRow()\n    let newContractCell = row.addButton(\"NEUER VERTRAG\");    \n    newContractCell.widthWeight = 100\n    newContractCell.onTap = () => {    \n        createNewContract()\n    }    \n\n    selectionTable.addRow(row)\n    \n    row = new UITableRow()\n    let newCheckCell = row.addButton(\"ALLE VERTRÄGE PRÜFEN\");\n    newCheckCell.onTap = () => {    \n        checkContracts()\n    }\n    selectionTable.addRow(row)\n\n    let buttonCell = [];\n    for (i = 0; i < filteredContractValues.length; i++ ) {        \n        let cellKey = filteredContractValues[i].ID;    \n        let row = new UITableRow();\n        let buttonCell =  row.addButton(contracts[cellKey].Titel + \" von \" + contracts[cellKey].Owner);   \n        buttonCell.onTap = () => {                        \n            contractKey = cellKey;\n            contractValue = contracts[cellKey]    \n            entry[contractKey] = contractValue;    \n            editAndSaveContract()    \n        }    \n\n        buttonCell.widthWeight = 100 \n        buttonCell.dismissOnTap = false      \n\n\n        let paymentCell\n        if ( contracts[cellKey].PaymentManagement === \"Ja\" ) {    \n            let selectedContract = new Object;\n            selectedContract[cellKey] = contracts[cellKey]\n            let monthlyRates = calculatePayments(selectedContract);\n            let paymentPicture;   \n            paymentPicture = balkenDiagramm(monthlyRates);\n            paymentCell = row.addImage(paymentPicture) \n        } else {\n            paymentCell = row.addText(\"\")\n        }\n        paymentCell.widthWeight = 50\n\n        let gantChartCell\n        if ( contracts[cellKey].AppointmentManagement === \"Ja\" ) {\n            gantChartPicture = GantChart([contracts[cellKey]])\n            gantChartCell = row.addImage(gantChartPicture) \n        } else {\n            gantChartCell = row.addText(\"\")\n        }\n        gantChartCell.widthWeight = 50\n        \n        selectionTable.addRow(row)  \n    }\n}\n\nasync function createNewContract(){        \n    contractValue = new Object();\n    for (let x of essentials){\n         contractValue[x] = await quickInput(x, \"\", false);    \n    }\n    contractValue.CreationDate = dfTime.string(today)\n    contractKey = contractValue.Owner + contractValue.Titel + contractValue.CreationDate;\n    contractValue.ID = contractKey;     \n    for (let x of Object.keys(metaData.EntryType[contractValue.EntryType])){    \n        contractValue[x] = metaData.EntryType[contractValue.EntryType][x]\n    }    \n    contracts[contractKey] = contractValue\n    editAndSaveContract()\n}\n\nasync function editContract() {    \n    await createContractTable()\n    await table.present()\n    return contractValue;\n}\n\nasync function editAndSaveContract(){\n   editContract().then(result =>{\n        if ( deletedObject === \"\" ) {\n            saveContract(contractKey, contractValue)    \n            if ( contractValue.AppointmentManagement === \"Ja\" ) {\n                createReminderAndEvent(contractKey, contractValue)\n            }\n        } else {\n            deletedObject = \"\"\n        }\n        selectionTable.reload()\n    })\n}\n\nasync function createContractTable() {    \n    let pictureRow = new UITableRow();\n    table.removeAllRows()    \n    table.dismissOnTap = false\n    let rowList = [];\n    let emptyCell;\n\n    rowList[0] = essentials;\n    await createRow(rowList[0], table, contractValue)\n    rowList[1] = [\"AppointmentManagement\"];        \n\n    if ( !(\"AppointmentManagement\" in contractValue) ) {\n        await quickInput(\"AppointmentManagement\", \"\", false).then(\n            output => {    \n                contractValue[\"AppointmentManagement\"] = output     \n            }\n        )\n    }\n    if (contractValue.AppointmentManagement === \"Ja\"){\n        rowList[1] = rowList[1].concat(essentialsAppointment)    \n        for (x of rowList[1]){\n            if ( !(x in contractValue) ){\n                await quickInput(x, \"\", false).then(\n                    output => {    \n                        contractValue[x] = output     \n                    }\n                )\n            }\n        }\n        contractValue = autoFill(contractValue)    \n        gantChartPicture = GantChart([contractValue])\n\n        var appointmentRow = new UITableRow();\n        var appointmentRow2 = new UITableRow();\n        eventCell = appointmentRow.addText(\"Kalendereintrag\", contractValue.Titel + \" von \" + contractValue.Owner + \"...\")\n        eventCell.subtitleColor = Color.gray()\n        eventCell.titleColor = Color.gray()\n        eventButton = appointmentRow2.addButton(\"... \" + contractValue.AppointmentSuffix)    \n        reminderCell = appointmentRow.addText(\"Erinnerung\", contractValue.Titel + \" von \" + contractValue.Owner + \"...\")\n        reminderCell.subtitleColor = Color.gray()\n        reminderCell.titleColor = Color.gray()    \n        reminderButton = appointmentRow2.addButton(\"... \" +contractValue.ReminderSuffix )\n        eventButton.onTap = () => {                \n            quickInput(\"AppointmentSuffix\", contractValue[\"AppointmentSuffix\"], false).then(\n                output => {    \n                    contractValue[\"AppointmentSuffix\"] = output         \n                    createContractTable()    \n                    table.reload()        \n                }\n            )    \n        }\n        reminderButton.onTap = () => {                \n            quickInput(\"ReminderSuffix\", contractValue[\"ReminderSuffix\"], false).then(output => {    \n                contractValue[\"ReminderSuffix\"] = output     \n                createContractTable()    \n                table.reload()    \n            })    \n        }\n        gantCell = appointmentRow.addImage(gantChartPicture)\n        emptyCell = appointmentRow2.addText()\n    }    \n    await createRow(rowList[1], table, contractValue)    \n\n    if (contractValue.AppointmentManagement === \"Ja\"){        \n        await table.addRow(appointmentRow)    \n        await table.addRow(appointmentRow2)\n    }\n\n    rowList[2] = [\"PaymentManagement\"];    \n    if ( !(\"PaymentManagement\" in contractValue) ) {\n        await quickInput(\"PaymentManagement\", \"\", false).then(\n            output => {    \n                contractValue[\"PaymentManagement\"] = output     \n            }\n        )\n    }\n    if (contractValue.PaymentManagement === \"Ja\"){\n        rowList[2] = rowList[2].concat( essentialsPayment )    \n        for (x of essentialsPayment){\n            if ( !(x in contractValue) ){\n                await quickInput(x, \"\", false).then(\n                    output => {    \n                        contractValue[x] = output     \n                    }\n                )\n            }\n        }\n        if ( contractValue.PaymentPeriod != \"1 Monat\" ){\n            rowList[2] = rowList[2].concat(\"PaymentDate\")    \n            if ( !(\"PaymentDate\" in contractValue) ) { \n                await quickInput(\"PaymentDate\", \"\", false).then(\n                    output => {    \n                        contractValue[\"PaymentDate\"] = output     \n                    }\n                )\n            }    \n        }\n    \n        entry[contractKey] = contractValue\n        let monthlyRates = calculatePayments(entry);\n        let balkenDiagrammImage;\n        balkenDiagrammImage = await balkenDiagramm(monthlyRates);\n        pictureRow.addImage(balkenDiagrammImage)\n    }    \n    await createRow(rowList[2], table, contractValue)   \n    if (contractValue.PaymentManagement === \"Ja\"){\n        await table.addRow(pictureRow)            \n    }\n    let allKeys = Object.keys(metaData)\n    let nonEssentialParameters = [];\n    for ( x of allKeys) {\n        if ( !(essentials.includes(x) || essentialsAppointment.includes(x) || essentialsPayment.includes(x) || unshownParameters.includes(x)) ) {\n            if ( x in contractValue ) {\n                nonEssentialParameters.push(x)\n            }\n        } \n    }\n    nonEssentialParameters.push(\"addParameter\")    \n    nonEssentialParameters.push(\"deleteContract\")    \n    var z = 3;\n    var s = 0;\n    rowList[z] = []\n    for ( x of nonEssentialParameters ) {\n        rowList[z] = rowList[z].concat(x);\n        s++\n        if ( s === 4) {    \n            s = 0\n            z++\n            rowList[z] = [];\n        }\n  \n    }     \n    for (let i = 3; i<= z; i++){\n         await createRow(rowList[i], table, contractValue)\n    }\n}\n\nasync function createRow(rowToConstruct, tableToConstruct, cValue) {        \n    var row = new UITableRow();\n        row.height = 80\n    var rowButton = new UITableRow();\n        rowButton.height = 40\n    var emptyRow = new UITableRow();\n        emptyRow.height = 20    \n    let output = [];\n\n    for (let key of rowToConstruct) {    \n        let cell;    \n        let cellButton;\n        switch ( key ) {\n        case \"addParameter\":    \n            cell = row.addText(\"\", \"Weitere Angaben einfügen\")\n            cellButton = rowButton.addButton(\"+\")\n            break;\n        case \"deleteContract\":\n            cell = row.addText(\"\", \"Vertrag entfernen\")\n            cellButton = rowButton.addButton(\"-\")\n            break;\n        default:\n            cell = row.addText(\"\", metaData[key].Klarname)\n            switch ( metaData[key].Typ ) {\n                case \"Text\":\n                    cellButton = rowButton.addButton(cValue[key])\n                    break;\n                case \"Number\":\n                    cellButton = rowButton.addButton(cValue[key].toString() + \" €\")\/\/ \n                    break;\n                case \"Date\":\n                    cellButton = rowButton.addButton(cValue[key])\n                    break;\n                default:        \n                    cellButton = rowButton.addButton(\"Nicht definiert\")\n            }            \n        }            \n        cell.widthWeight = 100\n        cell.subtitleColor = Color.gray()\n        cell.centerAligned()\n        cellButton.widthWeight = 100\n        cellButton.centerAligned()            \n        cellButton.onTap = () => {   \n            switch (key) {\n            case \"addParameter\":    \n                let newParameterAlert = new Alert();\n                    newParameterAlert.message = \"Welcher Wert soll ergänzt werden?\"\n                    newParameterAlert.title = \"Wert ergänzen\"    \n                let allKeys = Object.keys(metaData)        \n                let newParameterList = []\n                for ( x of allKeys) {    \n                    if (tableToConstruct === table) {\n                        if ( !(essentials.includes(x) || essentialsAppointment.includes(x) || essentialsPayment.includes(x) || unshownParameters.includes(x) || (x in cValue) ) ) {\n                            newParameterAlert.addAction(metaData[x].Klarname);\n                            newParameterList.push(x)\n                        }\n                    } else {\n                        if ( !(unshownParameters.includes(x) || (x in cValue) ) ) {\n                            newParameterAlert.addAction(metaData[x].Klarname);\n                            newParameterList.push(x)\n                        }\n                    }    \n                }\n                newParameterAlert.presentAlert().then(\n                    alertNumber => {\n                        let newParameter = newParameterList[alertNumber]\n                        quickInput(newParameter, \"\", false).then(    \n                            output => { \n                                if (tableToConstruct === table){    \n                                    contractValue[newParameter] = output     \n                                    createContractTable().then( () =>{ \n                                    tableToConstruct.reload()})\n                                } else {\n                                    filterObjects[newParameter] = output     \n                                    createSelectionTable().then( () =>{ \n                                    tableToConstruct.reload()})\n                                }\n                            }\n                        )    \n                    }\n                )\n                break;\n            case \"deleteContract\":\n                let confirmDeletingAlert = new Alert();\n                    confirmDeletingAlert.message = \"Löschen Bestätigen\"\n                    confirmDeletingAlert.title = \"Vertrag wirklich löschen?\"    \n                    confirmDeletingAlert.addDestructiveAction(\"Ja, löschen\");\n                    confirmDeletingAlert.addCancelAction(\"Abbrechen\");\n                    confirmDeletingAlert.presentAlert().then(\n                        yesNo => {\n                            if ( yesNo === 0 ){\n                                delete contracts[cValue.ID]\n                                deletedObject = cValue.ID\n                                fm.writeString(contractsFilePath, JSON.stringify(contracts))    \n                                tableToConstruct.removeAllRows()\n                                tableToConstruct.reload()\n                                return \"DELETED\"\n                            }\n                        }\n                    )\n                break;    \n            default:\n                 quickInput(key, cValue[key].toString(), true).then(    \n                    output => {\n                        if (tableToConstruct === table){    \n                            if ( output === \"DELETEVALUE\" ) {\n\/\/ ???                                delete contracts[contractKey][key] \n                                delete contractValue[key] \n                            } else {\n                                contractValue[key] = output     \n                            }\n                            createContractTable().then( () =>{ \n                            tableToConstruct.reload()})\n                        } else {\n                            if ( output === \"DELETEVALUE\" ) {\n                                delete filterObjects[key] \n                            } else {    \n                                filterObjects[key] = output     \n                            }\n                            createSelectionTable().then( () =>{ \n                            tableToConstruct.reload()})    \n                        }\n                    }\n                )    \n            }\n        } \n    }\n    for (i = rowToConstruct.length; i<4; i++) {\n        cell = row.addText(\"\")\n        cell.widthWeight = 100\n        cellButton = rowButton.addText(\"\")\n        cellButton.widthWeight = 100\n    }          \n    output[0] = row\n    output[1] = rowButton        \n    output[2] = emptyRow\n    tableToConstruct.addRow(row)    \n    tableToConstruct.addRow(rowButton) \n    tableToConstruct.addRow(emptyRow)        \n    return output;\n}\n\n\nasync function quickInput(key, value, deletingAllowed) {            \n    let inputType = metaData[key].Typ;\n    let userInput = new Alert();        \n        userInput.message = metaData[key].Beschreibung    \n        userInput.title = metaData[key].Klarname\n    let gewaehlt;\n    let output;\n    let constructList = [];\n    switch ( inputType ) {\n    case \"Text\":\n        if (!metaData[key].LimitedList) {    \n            userInput.addTextField(metaData[key].Klarname, value)\n            userInput.addAction(\"OK\");\n            constructList.push(\"OK\");        \n            if ( !metaData[key].collectData){\n                userInput.addAction(\"OK - Als Schnellbaustein sammeln\");\n                constructList.push(\"COLLECTDATA\");        \n            }\n        }                    \n        if ( deletingAllowed ) {\n            userInput.addDestructiveAction(\"Parameter Entfernen\")\n            constructList.push(\"DELETEVALUE\")\n        }\n        for (let i in metaData[key].Auswahlliste) {    \n            userInput.addAction(metaData[key].Auswahlliste[i])\n            constructList.push(metaData[key].Auswahlliste[i])\n        }\n        await userInput.presentAlert().then( choiceOfAlert => {      \n            switch ( constructList[choiceOfAlert]){\n            case \"OK\":    \n                output = userInput.textFieldValue(0)\n                break;\n            case \"COLLECTDATA\":\n            \t    output = userInput.textFieldValue(0)    \n                metaData[key].Auswahlliste.push(userInput.textFieldValue(0))\n                fm.writeString(metaDataFilePath, JSON.stringify(metaData))\n                break;    \n            case \"DELETEVALUE\":\n                output = \"DELETEVALUE\"\n                break;\n            default:     \n                output = constructList[choiceOfAlert]\n            }\n        })\n    \t break;\n    case \"Number\":\n        userInput.addTextField(metaData[key].Klarname, value)\n        userInput.addAction(\"OK\");    \n        constructList.push(\"OK\");        \n        if ( deletingAllowed ) {\n            userInput.addDestructiveAction(\"Parameter Entfernen\")\n            constructList.push(\"DELETEVALUE\")\n        }\n        await userInput.presentAlert().then( choiceOfAlert => {\n            switch ( constructList[choiceOfAlert]){\n\n            case \"OK\":    \n                if (userInput.textFieldValue(0).includes(\",\")){\n                    let partsOfString = userInput.textFieldValue(0).split(\",\")\n                    output = parseInt(partsOfString[0], 10) + parseInt(partsOfString[1], 10)\/(10**partsOfString[1].length)\n                } else if (userInput.textFieldValue(0).includes(\".\")){\n                    let partsOfString = userInput.textFieldValue(0).split(\".\")\n                    output = parseInt(partsOfString[0], 10) + parseInt(partsOfString[1], 10)\/(10**partsOfString[1].length)\n                } else {\n                    output = parseInt(userInput.textFieldValue(0), 10)\n                }\n                break;\n            case \"COLLECTDATA\":\n                if (userInput.textFieldValue(0).includes(\",\")){\n                    let partsOfString = userInput.textFieldValue(0).split(\",\")\n                    output = parseInt(partsOfString[0], 10) + parseInt(partsOfString[1], 10)\/(10**partsOfString[1].length)\n                } else if (userInput.textFieldValue(0).includes(\".\")){\n                    let partsOfString = userInput.textFieldValue(0).split(\".\")\n                    output = parseInt(partsOfString[0], 10) + parseInt(partsOfString[1], 10)\/(10**partsOfString[1].length)\n                } else {\n                    output = parseInt(userInput.textFieldValue(0), 10)\n                }\n                metaData[key].Auswahlliste.push(output)\n                fm.writeString(metaDataFilePath, JSON.stringify(metaData))\n                break;    \n            case \"DELETEVALUE\":\n                output = \"DELETEVALUE\"\n                break;\n            default:         \n            }\n        })\n        break;\n    case \"Date\":                \n        let rawDate;    \n        var inputDate = new DatePicker();\n        await inputDate.pickDate().then( rawDate => {\n            output = df.string(rawDate)\n        })\n\t\t break;    \n\tdefault:\n\t\t let elseAlert = new Alert();    \n        elseAlert.message = \"Datentyp von \" + key + \" nicht definiert \";\n    }            \n    return output;\n}\n\nfunction calculatePayments(contractList){        \n    let contracts = Object.values(contractList)\n    let monthlyMeanRate = [];\n    let monthlyPayments = contracts.filter(function (x) { return x.PaymentPeriod.includes(\"1 Monat\") } );\n    let quarterlyPayments = contracts.filter(function (x) { return x.PaymentPeriod.includes(\"3 Monate\")} );\n    let halfyearlyPayments = contracts.filter(function (x) { return x.PaymentPeriod.includes(\"6 Monate\") } );\n    let yearlyPayments = contracts.filter(function (x) { return x.PaymentPeriod.includes(\"1 Jahr\") } );\n    let regularMonthlyRate = 0;\n\n    for (x in monthlyPayments){  \n      regularMonthlyRate += monthlyPayments[x].PaymentValue\n    } \n    monthlyRates = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (j = 0; j < 12; j++) {\n        monthlyRates[j] = regularMonthlyRate\n    }\n    for (j = 0; j < yearlyPayments.length; j++) {\n        currentDate = new Date(Date.parse(yearlyPayments[j].PaymentDate));\n        monthlyRates[currentDate.getMonth()] += yearlyPayments[j].PaymentValue;\n    }\n    \/\/ Vierteljährliche Zahlungen\n    for (j = 0; j < quarterlyPayments.length; j++) {\n        currentDate = new Date(Date.parse(quarterlyPayments[j].PaymentDate));\n        payMonth = ((currentDate.getMonth() ) % 3) \n        for (k = 0; k < 4; k++) {\n            monthlyRates[payMonth + k * 3] += quarterlyPayments[j].PaymentValue;\n        }\n    }\n\n    \/\/ Halbjährliche Zahlungen\n    for (j = 0; j < halfyearlyPayments.length; j++) {\n        currentDate = new Date(Date.parse(halfyearlyPayments[j].PaymentDate));\n        payMonth = ((currentDate.getMonth() ) % 6) \n        for (k = 0; k < 2; k++) {\n            monthlyRates[payMonth + k * 6] += halfyearlyPayments[j].PaymentValue;\n        }\n    }\n\n    monthlyMeanRate = 0;\n    for (j = 0; j < 12; j++) {\n        monthlyMeanRate += monthlyRates[j]\/12\n    }\n    return monthlyRates\n}\n\nfunction saveContract(saveKey, saveValue){        \n    let value = saveValue\n        value.LastUpdate = dfTime.string(today)\n    contracts[saveKey] = value;\n    fm.writeString(contractsFilePath, JSON.stringify(contracts))\n}\n\nasync function checkContracts(){\n    let vertragsListe = Object.values(contracts);\n    let laufendeVertraege = vertragsListe.filter(function (x) { return x.Status == \"laufend\" });\n    let appointmentManagement = laufendeVertraege.filter(function (x) { return x.AppointmentManagement == \"Ja\" });\n    for ( i in appointmentManagement ) {\n        contractValue = appointmentManagement[i]\n        contractKey = contractValue.ID\n        await checkExtensionOfContract(contractKey, contractValue).then( result => {\n            if (result === 0) {    \n                createReminderAndEvent(contractKey, contractValue)\n            }\n        })\n    }\n}\n\nasync function retrieveEvents(){\n    return Calendar.forEventsByTitle(calendarName)\n    .then(\n        calValues => {\n            cal = calValues\n            return CalendarEvent.between(today, inOneYear , [calValues])\n        }\n    )\n    .then(\n        x => {\n            return x\n        }\n    )\n    .catch(e => log(\"There has been a problem with the calendar-request: \" + e.message))    \n}\n\nasync function retrieveReminders(){\n    return Calendar.forRemindersByTitle(reminderListName)\n    .then(remValues => {\n        return Reminder.allDueBetween(today, inThreeYears , [remValues])\n    })\n    .then(x => {                \n        return x\n    })\n    .catch(e => log(\"There has been a problem with the reminder-request: \" + e.message))    \n}\n\n\nasync function addTask(title, notes, startDate, dueDate, twoDoTags) {\n    \/\/Quelle: https:\/\/www.2doapp.com\/kb\/article\/url-schemes.html     \n    let baseURL = \"twodo:\/\/x-callback-url\/add\"        \n    let cb = new CallbackURL(baseURL)\n    cb.addParameter(\"task\", title)    \n    cb.addParameter(\"type\", \"0\") \/\/ type: Type of task to create. Following options are supported: \n    \/\/0 - Task (default)    \n    \/\/1 - Project    \n    \/\/2 - Checklist\n    cb.addParameter(\"forList\", reminderListName)    \n    \/\/cb.addParameter(\"forParentName\", projectTitle)\n    \/\/cb.addParameter(\"forParentUID\", projectID)    \n    cb.addParameter(\"tags\", twoDoTags)\/\/tags: Comma separated list of tags to assign to the task. New in v3.13: When the         supplied text is (clipboard), 2Do will copy the text from the clipboard.\n    \/\/locations: Comma separated list of locations to assign to the task. New in v3.13: When the supplied text is (clipboard), 2Do will copy the text from the clipboard.\n    cb.addParameter(\"note\", notes)\n    cb.addParameter(\"priority\", \"0\") \/\/priority: 0 (none), 1 (low), 2 (medium), 3 (high)\n    \/\/starred: 0 (no), 1 (yes)\n    cb.addParameter(\"due\", dueDate)\n\n\n     \/\/due: Due Date. Supports the format below:\n        \/*  yyyy-MM-dd - Sets on the date on default due time (based on your settings, unless due time is specified separately or ignoreDefaults is set to 1)\n        Any number - Number of days from Today, starting from 0. e.g. 0 = Today, 1 = Tomorrow and so on\n        In X days \/ weeks \/ months - Number of days from Today, e.g. In 3 days\n        Next Sunday \/ Monday etc - (new in iOS 3.13+) *\/\n    \/\/dueTime: Due Time. Supports format HH:mm or hh:mm am\/pm\n\n    cb.addParameter(\"start\", startDate)\n    \/\/start: Start Date and time. Supports the format below:\n    \/* yyyy-MM-dd HH:mm - Sets on the start date on the date and time specified\n    Any number - Number of days from Today, starting from 0. e.g. 0 = Today, 1 = Tomorrow and so on\n    In X days \/ weeks \/ months - Number of days from Today, e.g. In 3 days (new in iOS 3.13+)\n    Next Sunday \/ Monday etc -  (new in iOS 3.13+) *\/\n    \/\/repeat: 1 (daily), 2 (weekly), 3 (bi-weekly), 4 (monthly)\n    \/\/action: Supports the following formats:\n    \/*call:<number> - Add a Call action to call the specified number (without angle brackets)\n    message:<number> - Add a Message action to message the specified number (without angle brackets)\n    mail:<email> - Add a Email action to email the specified email address (without angle brackets)\n    url:<url to visit> - Add a Browse action to visit the specified URL address (without angle brackets)\n    visit:<address> - Add a Visit action to visit the specified address (without angle brackets)\n    google:<search term> - Add a Google action to search the specified keyword (without angle brackets) *\/\n    \/\/picture: This can be one of two things. If the value passed is ‘lastphoto’ (iOS only), 2Do will grab the most recent photo placed on your camera roll. If the pass value is a base64 encoded string, 2Do will convert it into an image and use that as the attachment.\n    \/\/audio: Provide a base64 encoded audio attachment\n    cb.addParameter(\"ignoreDefaults\", \"0\") \/\/ignoreDefaults: 0 (apply any default due date \/ time settings in app), 1 (ignore default dates \/ times) \n    \/\/saveInClipboard: (iOS 3.8.3+, Mac 2.2.2+) 0 (no), 1 (yes). The newly created task's unique identifier (UID) will be saved in the clipboard for easier retrieval.\n    cb.addParameter(\"edit\",\"0\") \/\/edit: 0 (the default; add a task in the background), 1 (show edit screen and allow you to edit within the app after creating the task)    \n\n\/\/    console.log(\"- addTask for \" + cb.getURL())\n    cb.open().then(result =>{    \n\/\/        log(\"  - 2Do callback returns \" )        \n        for (const [key, value] of Object.entries(result)) {\n            console.log(`${key}: ${value}`);    \n        }\n        if (result.add != \"\") {\n            let notify = new Notification()        \n                notify.title = \"Erinnerung angelegt\"    \n                notify.body = title\n                notify.schedule()\n     \t      return result.add\n        } else {    \n            console.error(\"Problem creating task in 2Do\" + title)\n     \t }\n     \t return 0        \n    })\n}\n\nasync function createReminderAndEvent(selectedContractKey, selectedContractValue){\n    let noteField = \"\";    \n    let noteFieldParameter = [\"Notes\", \"CustomerNumber\", \"Company\", \"NoticePeriod\", \"PaymentValue\", \"PaymentPeriod\", \"ID\"]\n    for (let noteElement of noteFieldParameter) {\n        if ( noteElement in selectedContractValue ) {\n            noteField += metaData[noteElement].Klarname + \": \" + selectedContractValue[noteElement] + \"\\n\"    \n        }    \n    }\n    if (df.date(selectedContractValue.EventDate) <= inOneYear ){\n        events = await eventPromises    \n        let filteredEvents = events.filter(\n            function (x) {        \n                return x.title.includes(selectedContractValue.Owner) && x.title.includes(selectedContractValue.Titel) && df.string(x.startDate) === selectedContractValue.EventDate\n            }    \n        );\n        if ( !(filteredEvents.length > 0) ) {        \n            let contractEvent = new CalendarEvent();\n                contractEvent.calendar = cal\n                contractEvent.title = selectedContractValue.Titel + \" von \" + selectedContractValue.Owner + \" \" + selectedContractValue.AppointmentSuffix    \n                contractEvent.isAllDay = true\n                contractEvent.startDate = df.date(selectedContractValue.EventDate)\n                contractEvent.endDate = df.date(selectedContractValue.EventDate)\n                contractEvent.notes = noteField + \"Erstellt am \" + dfTimeToDo.string(today) + \" mit scriptable. \"\n                contractEvent.save()\n            let notify = new Notification()        \n                notify.title = \"Kalendereintrag \" + selectedContractValue.Titel + \" von \" + selectedContractValue.Owner + \" angelegt\"    \n                notify.body = \"Fertig\"\n                notify.schedule()\n        \n        } else {    \n    log(\"Kalendereintrag NICHT erstellt: \" + selectedContractValue.Titel + \" von \" + selectedContractValue.Owner + \" am \" + selectedContractValue.EventDate + \" bereits vorhanden.\")    \n    \/\/            return \"nicht angelegt\"\n        }\n        eventPromises = retrieveEvents()    \n    } else {\n        log(\"Kalendereintrag NICHT erstellt: \" + selectedContractValue.Titel + \" von \" + selectedContractValue.Owner + \" am \" + selectedContractValue.EventDate + \" liegt mehr als 1 Jahr in der Zukunft.\")\n    }\n\n    if (df.date(selectedContractValue.ReminderEnd) <= inThreeYears ){\n        reminders = await reminderPromises    \n        let filteredReminders = reminders.filter(x =>{        \n            return x.title.includes(selectedContractValue.Owner) && x.title.includes(selectedContractValue.Titel) && df.string(x.dueDate) === selectedContractValue.ReminderEnd     \n        });\n        if ( !(filteredReminders.length > 0) ) {        \n            let title = selectedContractValue.Titel + \" von \" + selectedContractValue.Owner + \" \" + selectedContractValue.ReminderSuffix\n            let notes = selectedContractValue.Titel + \" von \" +  selectedContractValue.Owner + \" \" + selectedContractValue.AppointmentSuffix + \" am \" + selectedContractValue.EventDate +  \".\\n\" + noteField + \"Erstellt am \" + dfTimeToDo.string(today) + \" mit scriptable. \\n\"\n            let startDate = selectedContractValue.ReminderBegin + \" 12:00\"\n            let dueDate   = selectedContractValue.ReminderEnd\n            let twoDoTags = selectedContractValue.EntryType + \",\" + selectedContractValue.Owner + \",\" + \"Vertragsmanagement\"\n            addTask(title, notes, startDate, dueDate, twoDoTags)\n        } else {    \n    log(\"Erinnerung NICHT erstellt: \" + title + \" bis \" + selectedContractValue.ReminderEnd + \" bereits vorhanden.\")\n        }\n        reminderPromises = retrieveReminders()\n    } else {\n        log(\"Erinnerung NICHT erstellt: \" + selectedContractValue.Titel + \" von \" + selectedContractValue.Owner + \" am \" + selectedContractValue.EventDate + \" liegt mehr als 3 Jahre in der Zukunft.\")\n    }\n}\n\n\nasync function checkExtensionOfContract(key, value) {\n    let reminderBegin = new Date(Date.parse(value.ReminderBegin));    \n    let extendText;\n    if ( \"RenewalPeriod\" in value ) {\n        extendText = \"Vertrag um \" + value.RenewalPeriod + \" verlängern\"\n    } else {\n        extendText = \"Vertrag automatisch verlängern. \"\n    }\n    let renewalDecision = new Alert();\n        renewalDecision.title = value.Titel + \" von \" + value.Owner;\n        renewalDecision.message = \"Soll der Vertrag verlängert werden?\"\n        renewalDecision.addAction(\"Vertrag ist beendet.\")\n        renewalDecision.addAction(extendText)    \n        renewalDecision.addAction(\"Vertrag bearbeiten.\")\n        renewalDecision.addAction(\"Nicht jetzt - überspringen\")\n\n    var entry = new Object;    \n    entry[key] = value;\n\n    if ( reminderBegin <= today ){    \n        choice = await renewalDecision.present();\n        switch ( choice ){\n            case 0:\n\/\/                  Vertrag ist beendet.        \n                entry[key].Status = \"beendet\"                    \n                saveContract(entry)\n                return -1\n                break;\n            case 1:\n\/\/                  Vertrag automatisch verlängern\n                if ( !(\"RenewalPeriod\" in value) ) {\n                    quickInput(\"RenewalPeriod\", \"\").then(\n                        output => {    \n                            entry[key].RenewalPeriod = output     \n                        }\n                    )\n                }\n                entry[key].EventDate = changePeriod(entry[key].EventDate, entry[key].RenewalPeriod, false)\n                return 0\n                break;\n            case 2:\n\/\/                  Vertrag bearbeiten\n\n                await editContract(key, value);\n                return 0    \n                break;\n            case 3:\n            \/\/   Nicht jetzt - überspringen\n                break;\n            default:;\n            \n        }\n    } else {\n        return 0\n    }\n}\n\nfunction balkenDiagramm(werte){\n    let imageSize = 1200;\n    let imageHight = 200;  \n    let graphik = new DrawContext();    \n        graphik.size = new Size( imageSize, imageHight );\n        graphik.opaque = false;            \n    let spaceLeft = 5;\n    let spaceRight = 5;\n    let spaceTop = 5;\n    let spaceBottom = 5;  \n    let maximum = Math.max(...werte);  \n    let numberOfElements = werte.length;\n    let sum = 0;\n    let mean;\n    let stackScale = 80; \/\/ 0 .. 100. 100 Die Balken liegen aneinander an. 50: Abstand zwischen Balken und Balkenbreite ist gleich  \n    let stackWidth = (imageSize - spaceLeft - spaceRight)\/(numberOfElements + stackScale\/100)\n    let rect;\n    for (let i = 0; i < werte.length; i++) {    \n        sum += werte[i]\n        rect = new Rect(spaceLeft + i * stackWidth, (maximum - werte[i]) * (imageHight - spaceTop - spaceBottom) \/ maximum, stackScale\/100 * stackWidth, werte[i] \/ maximum * (imageHight - spaceTop - spaceBottom));  \n\n        if (werte[i] === 0) {    \n            rect = new Rect(spaceLeft + i * stackWidth, (maximum - 0.05 * maximum) * (imageHight - spaceTop - spaceBottom) \/ maximum, stackScale\/100 * stackWidth, 0.05 * maximum \/ maximum * (imageHight - spaceTop - spaceBottom));      \n        }    \n        if (i === today.getMonth()) {\n            graphik.setFillColor(Color.red())     \n        } else {\n            graphik.setFillColor(Color.darkGray())     \n        }\n        \n        graphik.fillRect(rect)\n    }\n    mean = sum\/12;        \n    pos = new Point(spaceLeft, 0)    \n    let font = Font.boldMonospacedSystemFont(200)\n    graphik.setFont(font)\n    let color = Color.lightGray()\n    graphik.setTextColor(color);    \n    if (!config.runsInWidget) graphik.drawText(mean.toFixed(2).toString() + \" €\", pos)\n    return graphik.getImage()\n}\n\nfunction autoFill(contract){    \n    let eventDate = new Date(Date.parse(contract.EventDate));\n    let period = contract.NoticePeriod;\n    contract.ReminderEnd = df.string(subtractPeriod(eventDate, period))\n\n    period = contract.PreparationPeriod\n    contract.ReminderBegin = df.string(subtractPeriod(contract.ReminderEnd, period))    \n    return contract\n}\n\nfunction subtractPeriod (investigatedDate, period) {\n    return changePeriod (investigatedDate, period, true)\n}\n\nfunction changePeriod (investigatedDate, period, subtract) {\n    const givenDate = new Date(Date.parse(investigatedDate))\n    let year = givenDate.getFullYear()\n    let month = givenDate.getMonth();\n    let day = givenDate.getDate();\n    var monthModifier = 0;\n    var weekModifier = 0;\n    var dayModifier = 0;\n    var splittedString = period.split(' ');\n\n    if (splittedString[1].includes(\"Monat\")){    \n        monthModifier = splittedString[0]\n    } else if (splittedString[1].includes(\"Woche\")){\n        weekModifier = splittedString[0]\n    } else if (splittedString[1].includes(\"Tag\")){\n        dayModifier = splittedString[0]\n    }    \n    if ( subtract ){\n        monthModifier *= -1\n        dayModifier *= -1\n        weekModifier *= -1\n    }\n\n    let newDate = new Date(year, month + monthModifier, day + dayModifier + 7 * weekModifier);    \n    return newDate\n}\n\nfunction GantChart(entrys){    \n\n    const progressBarLeftSpace = 5;\n    const progressBarRightSpace = 5;\n    const xachsesPositionFromTop = 3;    \n    const widthXAchses = ((config.runsInWidget)? 1 : 3);\n    const widthXTics = 2;\n    const lengthXTics = 6;\n    const widthProjectLine = ((config.runsInWidget)? 3 : 6);    \n    const widthDueLine = widthProjectLine; \n    const widthGrid = ((config.runsInWidget)? 0 : 1);\n    \n    const levelHight = widthProjectLine + widthDueLine + 3\n    \/\/ + ((config.runsInWidget)? 2 : 5);    \n\n    const projectLinePositionFromTop = xachsesPositionFromTop + widthXAchses + ((config.runsInWidget)? 2 : 4) ;\n    const dueLinePositionFromTop = projectLinePositionFromTop + widthDueLine;    \n    const progressTimePeriod = ((config.runsInWidget)? 0.5 : 1); \/\/ Length of the Progress Bar in years    \n    \n    const imageWidth = 500;\n    const xachsesLength = imageWidth - progressBarLeftSpace - progressBarRightSpace;\n    const minLength = ((config.runsInWidget)? 0.01 : 0.02); \/\/Percente of xachsesLength    \n    const maxLinesStackered = 5\n    \n    const imageHight = 80 \/\/2 * projectLinePositionFromTop + maxLinesStackered * levelHight\n   \n    \n\n    var year = today.getFullYear();    \n    var month = today.getMonth();    \n    var day = today.getDay();    \n    var oneYear = new Date(year + 1, month, day);    \n    var oneYearsLength = oneYear - today;\n\n    let progressBar = new DrawContext();\n        progressBar.size = new Size(imageWidth, imageHight);    \n        progressBar.opaque = false;\n    \n    let appointmentManagement = entrys;\n\n    let color = Color.darkGray();\n    let point1 = new Point(progressBarLeftSpace, xachsesPositionFromTop);\n    let point2 = new Point(progressBarLeftSpace + xachsesLength, xachsesPositionFromTop);\n    drawLine(point1, point2, color, widthXAchses)\n\n    var level = 0;\n  \n    for (let i = 1; i <= 12 * progressTimePeriod; i++ ) {\n        let xtic = new Date(year, month + i, day);\n        drawXTics(convertToUnity(xtic))\n        drawGrid(convertToUnity(xtic))\n   }\n  \n    progressBar.setTextColor( Color.red())\n    progressBar.setFont(Font.semiboldMonospacedSystemFont(16))\n    for (x in appointmentManagement){  \n        let reminderBeginDate = new Date(Date.parse(appointmentManagement[x].ReminderBegin));\n        let reminderBeginDatePosition = convertToUnity(reminderBeginDate)\n        let reminderEndDate = new Date(Date.parse(appointmentManagement[x].ReminderEnd));\n        let reminderEndDatePosition = convertToUnity(reminderEndDate)\n        let eventDate = new Date(Date.parse(appointmentManagement[x].EventDate));\n        let eventDatePosition = convertToUnity(eventDate)\n\n        drawProjectLine(reminderBeginDatePosition, reminderEndDatePosition, level)\n        drawDueLine(reminderEndDatePosition, eventDatePosition, level)\n        level++    \n        if (level === maxLinesStackered){ level = 0 }\n    }\n    return progressBar.getImage()\n\n    function drawLine(point1, point2, color, width){\n        let line = new Path()\n            line.move(point1)\n            line.addLine(point2)\n        progressBar.addPath(line)\n        progressBar.setStrokeColor(color)\n        progressBar.setLineWidth(width)\n        progressBar.strokePath()  \n    }\n    function drawXTics(x){\n        let color = Color.darkGray();\n        let point1 = new Point(progressBarLeftSpace + x * xachsesLength, xachsesPositionFromTop);\n        let point2 = new Point(progressBarLeftSpace + x * xachsesLength, xachsesPositionFromTop + lengthXTics);\n        drawLine(point1, point2, color, widthXTics)\n    }\n\n    function drawProjectLine(x1, x2, level) {\n        let color = Color.blue();\n        let point1 = new Point(progressBarLeftSpace + Math.max(Math.min(x1 * xachsesLength, (1 - minLength) * xachsesLength), 0), projectLinePositionFromTop  + levelHight * level);\n        let point2 = new Point(progressBarLeftSpace + Math.max(Math.min(x2 * xachsesLength, 1 * xachsesLength), minLength * xachsesLength), projectLinePositionFromTop  + levelHight * level);\n        drawLine(point1, point2, color, widthProjectLine)\n    }\n\n    function drawDueLine(x1, x2, level) {\n        let color = Color.green();\n        let point1 = new Point(progressBarLeftSpace + Math.max(Math.min(x1 * xachsesLength, (1 - minLength) * xachsesLength), 0), dueLinePositionFromTop  + levelHight * level);\n        let point2 = new Point(progressBarLeftSpace + Math.max(Math.min(x2 * xachsesLength, 1 * xachsesLength), minLength * xachsesLength), dueLinePositionFromTop  + levelHight * level);\n          drawLine(point1, point2, color, widthDueLine)\n    }\n\n    function drawGrid(x){\n        let color = Color.darkGray();\n        let point1 = new Point(progressBarLeftSpace + x * xachsesLength, xachsesPositionFromTop);\n        var point2 = new Point(progressBarLeftSpace + x * xachsesLength, imageHight);\n        drawLine(point1, point2, color, widthGrid)\n    }\n\n    function convertToUnity(date){\n        return (date - today)\/oneYearsLength\/progressTimePeriod\n    }\n}",
  "share_sheet_inputs" : [

  ]
}